/**
* @file: matrix_generator.cpp
* @brief:
* @author: Changjiang Cai, ccai1@stevens.edu, caicj5351@gmail.com
* @version: 0.0.1
* @creation date: 17-12-2015
* @last modified: Thu 10 Mar 2016 09:32:02 AM EST
*/

#include "matrix_generator.hpp"
#include "MyUtility.hpp"
#include <vector>
#include <random>
#include <cmath>
#include <chrono>
#include <map>
#include "truth_discovery.hpp"
#include "Experiment.hpp"

using namespace std;
using namespace td_wieghts; // truth discovery;
extern std::default_random_engine generator_main;
extern double _ACCURCY ;
extern int  totalTime;
extern vector<int> v_smoothing_counts;
extern vector<double > v_smoothing_time_debug;
extern int temp_main;
extern double ratio_main;

// some of the codes are generated by Boxiang Do.

/* Generates preference for one pairwise comparison task.
 * compare O_i > o_j or not,
 * if O_i > o_j, return true;
 * if O_i < o_j, return false.
 * Rule: 
 * 1) r_i means the ranking of o_i, the less the better.
 * 2) e_i means the noisy of r_i, where e_i ~ N(mean, stddev^2) Gaussian Distribution.
 * 3) Therefore, Prob(o_i > o_j) = Prob(r_i + e_i < r_j + e_j ) 
 *    = Prob(r_i - r_j < e_j - e_i) = Prob(delta(r_ij) - delta(e_ji) < 0)
 *    where, e_j - e_i ~ N(mean, 2 * stddev^2).
 */
bool generate_sim_vote_for_one_task(
	const int & n, // vertex number
	const int & rank_o_i,
	const int & rank_o_j, // less rank is better.
	const double& stddev /*Gaussian variance to control the worker's quality.*/
	){
	
	std::normal_distribution<double> dist(0.0, stddev);
	std::uniform_real_distribution<double> uniform_distribution(0.0, 1.0);
	double error = abs(dist(generator_main)); //the error ratio for the worker
	double 	fraction = uniform_distribution(generator_main);
	if (((rank_o_j > rank_o_i) && (fraction >= error)) || ((rank_o_j < rank_o_i) && (fraction < error))) {
		return true;
	}
	else {
		return false;
	}
}


bool generate_sim_vote_for_one_task_for_CrowdBT(
	const int & n, // vertex number
	const int & rank_o_i,
	const int & rank_o_j, // less rank is better.
	const double & a, //beta distribution parameter.
	const double & b //beta distribution parameter.
	){

	std::uniform_real_distribution<double> unif(0, 1);
	double p = unif(generator_main);
	// eta follows the beta distribution, Beat(a, b).
	// 0 < eta < 1 
	double eta = 10;
	while (true){
		eta = boost::math::ibeta_inv(a, b, p);
		if (abs(eta) > 0.0 && abs(eta) < 1.0)
			break;
	}

	double stddev = 1 - eta;
	//unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
	//auto engine = std::default_random_engine(seed);

	// newly added.
	// result_type mean = 0.0, result_type stddev = 1.0
	std::normal_distribution<double> dist(0, stddev);
	std::uniform_real_distribution<double> uniform_distribution(0.0, 1.0);

	double error = abs(dist(generator_main)); //the error ratio for the worker
	double 	fraction = uniform_distribution(generator_main);
	if (((rank_o_j > rank_o_i) && (fraction >= error)) || ((rank_o_j < rank_o_i) && (fraction < error))) {
		return true;
	}
	else {
		return false;
	}
}


// based on the task assignment graph, do preference voting;
// for example, if (o_i, o_j) is assigned in the task assignment graph,
// that is GT[i][j] == true, then a worker will vote for which he/she will
// prefer. If he/she prefer o_i > o_j, the matrix[i][j] = 1, matrix[j][i] = 0;
// there will a directed edge (o_i, o_j).

vector<vector<int>> generate_sim_vote(const int& n, bool **GT,
	// ground_truth: <key = object_i, value = rank of object_i>;
	const map<int, int>& ground_truth, 
	const double& stddev, /*Gaussian variance to control the worker's quality.*/
	const int & max_per_worker // maximum number of pairwise comparison per worker can do.
	// if max_per_worker < 0, that means doing all the pairwise comparasions.
	){

	vector<vector<int>> matrix(n, vector<int>(n, 0));
	//unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
	//auto engine = std::default_random_engine(seed);
	// std::default_random_engine engine;
	// newly added.
	//std::normal_distribution<double> dist(mean, stddev);

	// all the edges in G_T (i.e, task assignment graph)
	vector<pair <int, int>> v_edges;
	for (int i = 0; i < n; ++i){
		for (int j = 0; j < i; ++j){
			if (GT[i][j] == true)
				v_edges.push_back(make_pair(i, j)); // i > j;
		}
	}

	
	int edge_num = v_edges.size();
	// number of tasks for this worker.
	int num_task = (max_per_worker > 0) ?
		min(max_per_worker, edge_num) : edge_num;
	
	if (num_task < edge_num){
	// randomize the order of those edges;
	    std::random_shuffle(v_edges.begin(), v_edges.end());
	}

	for (int task_idx = 0; task_idx < num_task; ++task_idx){
		// i > j
		int i = v_edges[task_idx].first;
		int j = v_edges[task_idx].second;


		bool Is_i_better = generate_sim_vote_for_one_task(
			n, // vertex number
			ground_truth.at(i), ground_truth.at(j),
			stddev /*Gaussian variance to control the worker's quality.*/
			);

		// Since less ranking means preferred objects.
		if (!Is_i_better) { /* o_i < o_j <===> (i <-- j)*/
			matrix[i][j] = 0;
			matrix[j][i] = 1;
		}
		else { /* o_i > o_j <===> (i --> j)*/
			matrix[i][j] = 1;
			matrix[j][i] = 0;
		}

	} // end of tasks for one worker.

	//Initialize the diagonal elements to 0;
	for (int i = 0; i < n; ++i){
		matrix[i][i] = 0;
	}
	// release the memory.
	vector<pair<int, int>>().swap(v_edges);
	// print_2D_vector<int>(n, matrix);
	return matrix;

}



// for all the workers, gathering their voting results.
vector<vector<vector<int>>> generate_sim_votes(
	const int& n, const int& w, bool **GT,
	const map<int, int>& ground_truth, const int& distribution,
	const int& quality, // different levels of error-rate for the worker's quality.
	const int & max_per_worker /*maximum number of pairwise comparison per worker can do.*/
	){

	vector<vector<vector<int>>> matrice;
	double stddev = 0.001;
	std::normal_distribution<double> normal_dist;
	std::uniform_real_distribution<double> uniform_dist;

	if (distribution == NORMAL_DISTRIBUTION) {
		switch (quality) {
		case LOW_QUALITY:
			normal_dist = std::normal_distribution<double>(0, low_guassian);
			break;
		case MEDIUM_QUALITY:
			normal_dist = std::normal_distribution<double>(0, medium_guassian);
			break;
		case HIGH_QUALITY:
			normal_dist = std::normal_distribution<double>(0, high_guassian);
			break;
		default:
			break;
		}


		// Since all the tasks should be finished at least by one worker.
		// Therefore, we should guarantee that there exists at least 1 worker
		// who finishes all the pairwise comparison.

		// 1) for worker 1:
		//generate the standard deviation
		stddev = abs(normal_dist(generator_main));
		matrice.push_back(generate_sim_vote(n, GT, ground_truth, stddev, -1/*max_per_worker*/));

		// 2) for other workers.
		for (int ww = 1; ww < w; ww++){
			matrice.push_back(generate_sim_vote(n, GT, ground_truth, stddev, max_per_worker));
		}
	}
	else {
		switch (quality) {
		case LOW_QUALITY:
			uniform_dist = std::uniform_real_distribution<double>(low_uniform_left, low_uniform_right);
			break;
		case MEDIUM_QUALITY:
			uniform_dist = std::uniform_real_distribution<double>(medium_uniform_left, medium_uniform_right);
			break;
		case HIGH_QUALITY:
			uniform_dist = std::uniform_real_distribution<double>(high_uniform_left, high_uniform_right);
			break;
		default:
			break;
		}

		// Since all the tasks should be finished at least by one worker.
		// Therefore, we should guarantee that there exists at least 1 worker
		// who finishes all the pairwise comparison.

		// 1) for worker 1:
		//generate the standard deviation
		stddev = abs(uniform_dist(generator_main));
		matrice.push_back(generate_sim_vote(n, GT, ground_truth, stddev, -1/*max_per_worker*/));

		// 2) for other workers.
		for (int ww = 1; ww < w; ww++){
			matrice.push_back(generate_sim_vote(n, GT, ground_truth, stddev, max_per_worker));
		}
	}

	return matrice;
}


// for all the workers, gathering their voting results.
// in the format of <task_id, which_object_is_preferred>.
void generate_sim_votes_taskID_who(
	const int& n, const int& w, bool **GT,
	const vector<vector<vector<int>>> & matrice,
	// store the tasks;
	// The task-IDs' are assigned based on way the double-for-loop is executed.
	vector<vector <td_wieghts::client_vote>> & v_client_votes
	){
	
	// store the tasks;
	// The task-IDs' are assigned based on way the double-for-loop is executed.
	// vector <td_wieghts::client_vote> v_client_votes;

	if (v_client_votes.size() < w){
		v_client_votes.clear();
		v_client_votes = vector<vector<client_vote>>(w, vector<client_vote>(0));
	}
		
	for (int ww = 0; ww < w; ++ww){
		int task_id = 0;
		int who = 0;
		// each work will vote some tasks;
		for (int i = 0; i < n; ++i){
			for (int j = 0; j < i; ++j){
				if (GT[i][j] == true){
					if (matrice[ww][i][j] > 0){
						who = i;
						v_client_votes[ww].push_back(client_vote(task_id, who));
					}
					else if (matrice[ww][j][i] > 0){
						who = j;
						v_client_votes[ww].push_back(client_vote(task_id, who));
					}
					else { /*do nothing*/ }

					task_id++;
				}
			}
		}
	}/*end of each worker*/

}


// SATD (i.e., SA with Truth Discovery to update the weights)
// truth discovery;
vector<vector <td_wieghts::client_vote>> generate_aggregated_matrix_SATD(
	bool **GT, const vector<vector<vector<int>>> & matrice,
	vector<vector<double>> & gp,
	vector<double> & worker_weights,
	td_wieghts::truth_discovery * td,
	const int & max_task_num,
	int & count, // Truth discovery execution times.
	/*Smothing_Type : */
	/* You have to specify the default values
	* for the arguments only in the declaration
	* but not in the definition.*/
	const int & smothingType
	){		
	// worker number;
	const int w = (int)matrice.size();
	// object number;
	const int n = (int)matrice[0].size();

	//**************************
	// stackover flow error;
	// since this class/structure allocates many arrays in stack.
	//**************************
	

	vector<vector <td_wieghts::client_vote>> v_client_votes = 
		vector<vector<client_vote>>(w, vector<client_vote>(0));
	generate_sim_votes_taskID_who(n, w, GT, matrice, v_client_votes);
	
	// when you start my program at the first time, 
	// you must **execute init(1)**. And for the later 
	// exp (**10 time for the same size of data**), 
	// you **exec init(0)**.
	td->init(0, n, w, max_task_num);
	// store the tasksbased on the following 2-loop order;
	vector <pair<int, int>> v_tasks;
	for (int i = 0; i < n; ++i){
		for (int j = 0; j < i; ++j){
			if (GT[i][j] == true){
				v_tasks.push_back(make_pair(i, j));
				// "+1", since Haipei's code uses 1-based index.
				td->store_task_pair(i + 1, j + 1);
				//cout << i + 1 << ", " << j + 1 << endl;
			}
		}
	}

	// ??????????????
	// each work will vote for some tasks;
	for (int ww = 0; ww < w; ++ww){
		for (auto & task : v_client_votes[ww]){
			// "+1", since Haipei's code use 1-based index.
			td->store_worker_decisions(ww + 1, task.task_id + 1, task.who + 1);
		}
	}
	
	//string na = "E:\\OpenCVProjects_CCJ\\CrowdSourcing2\\ICDE-2017\\AMT\\G_P_For_Each_Worker\\voting.txt";
	//std::ofstream of(na.c_str(), std::ofstream::out);
	//td->print_worker_decisions(of);
	//of.close();
	td->iteration_main(_ACCURCY, totalTime, count);


	//std::vector<std::vector<double>> gp;
	for (int i = 0; i < n; i++) {
		gp.push_back(vector<double>(n, 0.0));
	}

	int idx = 1;
	for (auto & task : v_tasks){
		// return scores of pairwise comparison tasks;
		int i = task.first;
		int j = task.second;
		gp[i][j] = (double) td->load_x(false)[idx];
		gp[j][i] = 1.0 - gp[i][j];
		idx++;
		// return the quality of workers.
	}

	for (int ww = 0; ww < w; ++ww){
		// "+1", since Haipei's code uses 1-based index.
		worker_weights[ww] = td->load_w(false)[ww +1];
	}
	// release memory;
	return v_client_votes;
}


double small_prob(const double & worker_weight, const double & mean,
	const double & prob_threshold, /*a threshold of the small_prob to be generated.*/
	const double & stddev_scalar){
	double stddev = 10;
	if (worker_weight == 0)
		stddev = (-1.0)*log10(worker_weight + NEARLY_ZERO);
	else 
		stddev = (-1.0)*log10(worker_weight);
	std::normal_distribution<double> dist(mean, stddev_scalar * stddev);
	//the error ratio for the worker
	double noise = 100;
	while (true){
		noise = abs(dist(generator_main));
		if (noise <= prob_threshold)
			break;
	}
	return noise;
}


void Smoothing_UpdateProb_with_Workers_Quality(
	const vector<double> & worker_weights,
	bool **GT, const int & n, /*object number*/
	const double & prob_threshold, /*a threshold of the small_prob to be generated.*/
	const double & mean, const double & stddev_scalar,
	const vector<vector <td_wieghts::client_vote>> & v_client_votes,
	vector<vector<double>> & gtc){
	
	const int w = worker_weights.size();
	
	auto t_start = std::chrono::high_resolution_clock::now();

	// get all the pairwise comparison tasks.
	vector <pair<int, int>> v_tasks;
	for (int i = 0; i < n; ++i){
		for (int j = 0; j < i; ++j){
			if (GT[i][j] == true){
				v_tasks.push_back(make_pair(i, j));
			}
		}
	}


	// build a mapping : for each edge, we collect which workers
	// vote on the edge, saving the worker ID, worker  quality (i.e., worker's weight).
	vector<vector<pair<int, double>>> edge_worker_map(v_tasks.size(), 
		vector<pair<int, double>>(0, make_pair(0, 0.0)));
	
	

	// each work will vote for some tasks;
	for (int ww = 0; ww < w; ++ww){
		for (auto & task : v_client_votes[ww]){
			edge_worker_map[task.task_id].push_back(make_pair(ww, worker_weights[ww]));
		}
	}
	auto t_end = std::chrono::high_resolution_clock::now();
	v_smoothing_time_debug[0] = 1.e-9*std::chrono::duration_cast<std::chrono::nanoseconds>(t_end - t_start).count();
	
	int temp_main = 0;
	auto t_start1 = std::chrono::high_resolution_clock::now();
	for (auto & task : v_tasks){
		// return scores of pairwise comparison tasks;
		int t_idx = 0; /*task idx*/
		int i = task.first;
		int j = task.second;
		double sum = gtc[i][j] + gtc[j][i];

		if ((sum > 0) && (gtc[i][j] < NEARLY_ZERO)){
		//if ((sum > 0) && (gtc[i][j] <= gtc[j][i])){
			// for each worker involving in this task.
			double delta = 0.0;
			int k_size = edge_worker_map[t_idx].size();
			for (int k = 0; k < k_size; ++k){ 
				double worker_weight = edge_worker_map[t_idx][k].second;

				t_start = std::chrono::high_resolution_clock::now();
				delta += small_prob(worker_weight, mean, prob_threshold, stddev_scalar);
				t_end = std::chrono::high_resolution_clock::now();
				v_smoothing_time_debug[2] += 1.e-9*std::chrono::duration_cast<std::chrono::nanoseconds>(t_end - t_start).count();
			}
			delta /= k_size;
			gtc[i][j] += delta;
			gtc[j][i] -= delta;
			temp_main++;
		}
		else if ((sum > 0) && (abs(1.0 - gtc[i][j]) < NEARLY_ZERO))
		//else if ((sum > 0) && (gtc[i][j] > gtc[j][i]))
		{
			// for each worker involving in this task.
			double delta = 0.0;
			int k_size = k_size = edge_worker_map[t_idx].size();
			for (int k = 0; k < k_size; ++k){
				double worker_weight = edge_worker_map[t_idx][k].second;
				t_start = std::chrono::high_resolution_clock::now();
				delta += small_prob(worker_weight, mean, prob_threshold, stddev_scalar);
				t_end = std::chrono::high_resolution_clock::now();
				v_smoothing_time_debug[2] += 1.e-9*std::chrono::duration_cast<std::chrono::nanoseconds>(t_end - t_start).count();
			}
			delta /= k_size;
			gtc[i][j] -= delta;
			gtc[j][i] += delta;
			temp_main++;
		}
		else {};

		t_idx++;
	}

	t_end = std::chrono::high_resolution_clock::now();
	v_smoothing_time_debug[1] = 1.e-9*std::chrono::duration_cast<std::chrono::nanoseconds>(t_end - t_start1).count();
	v_smoothing_time_debug[3] = temp_main;
	//release memory
	t_start = std::chrono::high_resolution_clock::now();
	vector <pair<int, int>>().swap( v_tasks);
	vector<vector<pair<int, double>>>().swap(edge_worker_map);
	t_end = std::chrono::high_resolution_clock::now();
	v_smoothing_time_debug[0] += 1.e-9*std::chrono::duration_cast<std::chrono::nanoseconds>(t_end - t_start).count();

}


std::vector<std::vector<double> > generate_aggregated_matrix(
	const int& n, const int& w, bool **GT,
	const std::map<int, int>& ground_truth, const int& distribution,
	const int& quality, // different levels of error-rate for the worker's quality.
	const int & max_per_worker, // maximum number of pairwise comparison per worker can do.
	/*Smothing_Type : */
	/* You have to specify the default values
	* for the arguments only in the declaration
	* but not in the definition.*/
	const int & smothingType
	){
	std::vector<std::vector<std::vector<int> > > matrice;
	vector<vector<double> > matrix, operand;

	//get all the worker's results
	matrice = generate_sim_votes(n, w, GT, ground_truth, distribution, 
		quality, max_per_worker);

	//add
	//matrix = matrice[0];
	for (int i = 0; i < n; i++) {
		matrix.push_back(vector<double>(matrice[0][i].begin(), matrice[0][i].end()));
	}

	for (int i = 1; i < w; i++) {
		operand.clear();
		for (int j = 0; j < n; j++)
			operand.push_back(vector<double>(matrice[i][j].begin(), matrice[i][j].end()));
		matrix = add(matrix, operand);
	}

	//unify, i.e., 
	// matrix[i][j] =  matrix[i][j] / ( matrix[i][j] +  matrix[j][i]).
	switch (smothingType){
		switch (smothingType){
		case DIRECT_USE_WEIGHTS:
			unify_BT_D(matrix);
			break;
		case EXPONENTIAL_USE_WEIGHTS:
			unify_BT_E(matrix);
			break;
		case LAPLACE_SMOTHING:
			unify_BT_L(matrix, 1.0);
			break;
		}
	}
	
	return matrix;
}

std::vector<std::vector<double>>
generate_aggregated_matrix(const vector<vector<vector<int> >> & matrice,
/*Smothing_Type : */
/* You have to specify the default values
* for the arguments only in the declaration
* but not in the definition.*/
const int & smothingType){
	vector<vector<double> > matrix, operand;

	int w = (int)matrice.size();
	int n = (int)matrice[0].size();

	//add
	//matrix = matrice[0];
	for (int i = 0; i < n; i++) {
		matrix.push_back(vector<double>(matrice[0][i].begin(), matrice[0][i].end()));
	}

	for (int i = 1; i < w; i++) {
		operand.clear();
		for (int j = 0; j < n; j++)
			operand.push_back(vector<double>(matrice[i][j].begin(), matrice[i][j].end()));
		matrix = add(matrix, operand);
	}

#if 0
	cout << "Aggregated voting matrix is:\n";
	print_2D_vector<double>(n, matrix);
#endif
		switch (smothingType){
		case DIRECT_USE_WEIGHTS:
			unify_BT_D(matrix);
			break;
		case EXPONENTIAL_USE_WEIGHTS:
			unify_BT_E(matrix);
			break;
		case LAPLACE_SMOTHING:
			unify_BT_L(matrix, 1.0);
			break;
		}

#if 0
		cout << "Normalized Aggregated voting matrix is:\n";
		print_2D_vector<double>(n, matrix);
#endif
	return matrix;
}


std::vector<std::vector<int>> generate_aggregated_voting_matrix(
const std::vector<std::vector<std::vector<int> >> & matrice){

	vector<vector<int> > matrix, operand;

	int w = (int)matrice.size();
	int n = (int)matrice[0].size();

	//add
	//matrix = matrice[0];
	for (int i = 0; i < n; i++) {
		matrix.push_back(vector<int>(matrice[0][i].begin(), matrice[0][i].end()));
	}

	for (int i = 1; i < w; i++) {
		operand.clear();
		for (int j = 0; j < n; j++)
			operand.push_back(vector<int>(matrice[i][j].begin(), matrice[i][j].end()));
		matrix = add(matrix, operand);
	}
	
	return matrix;
}